<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIAXUS Real-time Oceanographic Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 1em;
            opacity: 0.9;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9em;
        }
        
        .control-group select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .control-group button {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f9fa;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        
        .control-group button:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }
        
        .control-group button:active {
            background: #dee2e6;
        }
        
        .status {
            background: rgba(52, 152, 219, 0.1);
            padding: 8px 20px;
            text-align: center;
            border-left: 4px solid #3498db;
            font-size: 0.9em;
        }
        
        .main-content {
            flex: 1;
            display: grid;
            grid-template-rows: auto 3fr;
            gap: 10px;
            padding: 10px;
            min-height: 0;
        }
        
        .map-section {
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .map-section h3 {
            font-size: 1.1em;
            margin-bottom: 8px;
            color: #2c3e50;
            text-align: center;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }
        
        .map-section #map-plot {
            flex: 1;
            min-height: 500px;
        }
        
        .charts-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            min-height: 0;
        }
        
        .chart-box {
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            min-height: 300px;
        }
        
        .chart-box h3 {
            font-size: 1em;
            margin-bottom: 8px;
            color: #2c3e50;
            text-align: center;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }
        
        .chart-box div {
            flex: 1;
            min-height: 200px;
        }
        
        .legend {
            text-align: center;
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }
        
        .footer {
            background: rgba(44, 62, 80, 0.1);
            padding: 8px;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.8em;
        }
        
        @media (max-width: 768px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
            
            .chart-box {
                min-height: 250px;
            }
            
            .map-section #map-plot {
                min-height: 400px;
            }
            
            .controls {
                flex-direction: column;
                gap: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .main-content {
                padding: 5px;
                gap: 5px;
            }
            
            .map-section, .chart-box {
                padding: 5px;
            }
            
            .chart-box {
                min-height: 200px;
            }
            
            .map-section #map-plot {
                min-height: 350px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>TRIAXUS Real-time Oceanographic Dashboard</h1>
        <p>Live oceanographic data visualization and monitoring</p>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <label for="refreshRate">Refresh:</label>
            <select id="refreshRate">
                <option value="500">0.5s</option>
                <option value="1000">1s</option>
                <option value="2000">2s</option>
                <option value="5000" selected>5s</option>
                <option value="10000">10s</option>
                <option value="30000">30s</option>
                <option value="60000">1min</option>
                <option value="300000">5min</option>
                <option value="0">Manual</option>
            </select>
        </div>
        <div class="control-group">
            <label for="plotType">Plot:</label>
            <select id="plotType">
                <option value="all" selected>All</option>
                <option value="timeseries">Time Series</option>
                <option value="profile">Profile</option>
                <option value="map">Map</option>
            </select>
        </div>
        <div class="control-group">
            <label for="timeGranularity">Time Range:</label>
            <select id="timeGranularity">
                <option value="1h">Last 1 Hour</option>
                <option value="6h">Last 6 Hours</option>
                <option value="12h">Last 12 Hours</option>
                <option value="24h" selected>Last 24 Hours</option>
                <option value="3d">Last 3 Days</option>
                <option value="7d">Last 7 Days</option>
                <option value="30d">Last 30 Days</option>
                <option value="all">All Data</option>
            </select>
        </div>
        <div class="control-group">
            <label for="mapZoom">Zoom:</label>
            <select id="mapZoom">
                <option value="6">6 (Wide)</option>
                <option value="8">8</option>
                <option value="10">10</option>
                <option value="12">12</option>
                <option value="14">14</option>
                <option value="16">16</option>
                <option value="18" selected>18 (Micro)</option>
                <option value="20">20 (Detail)</option>
            </select>
        </div>
        <div class="control-group">
            <button id="manualRefresh" style="padding: 5px 10px; border: 1px solid #ddd; border-radius: 4px; background: #f8f9fa; cursor: pointer;">Manual Refresh</button>
        </div>
    </div>
    
    <div class="status" id="status">
        <strong>Status:</strong> <span id="statusText">Connecting...</span> | 
        <strong>Last Update:</strong> <span id="lastUpdate">Never</span> | 
        <strong>Records:</strong> <span id="recordCount">0</span>
    </div>
    
    <div class="main-content">
        <div class="charts-section">
            <div class="chart-box">
                <h3>Temperature</h3>
                <div id="temp-plot"></div>
            </div>
            <div class="chart-box">
                <h3>Salinity</h3>
                <div id="salinity-plot"></div>
            </div>
            <div class="chart-box">
                <h3>Oxygen</h3>
                <div id="oxygen-plot"></div>
            </div>
            <div class="chart-box">
                <h3>Depth Profile</h3>
                <div id="profile-plot"></div>
            </div>
        </div>
        
        <div class="map-section">
            <h3>Oceanographic Map</h3>
            <div id="map-plot"></div>
            <div class="legend">
                <span style="color: #e74c3c;">Current Position</span> | 
                <span style="color: #3498db;">Trajectory</span> | 
                <span style="color: #95a5a6;">History</span>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>TRIAXUS Oceanographic Data Visualization System | Real-time Monitoring Dashboard</p>
    </div>

    <script>
        let refreshInterval;
        let currentData = [];
        let mapZoomLevel = 18;

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            fetchData();
            startAutoRefresh();
        });

        function setupEventListeners() {
            document.getElementById('refreshRate').addEventListener('change', function() {
                clearInterval(refreshInterval);
                startAutoRefresh();
            });

            document.getElementById('plotType').addEventListener('change', function() {
                updatePlotVisibility();
            });

            document.getElementById('timeGranularity').addEventListener('change', function() {
                console.log('Time granularity changed to:', this.value);
                if (currentData.length > 0) {
                    updateAllPlots();
                }
            });

            document.getElementById('mapZoom').addEventListener('change', function() {
                mapZoomLevel = parseInt(this.value);
                if (currentData.length > 0) {
                    updateMapPlot();
                }
            });

            document.getElementById('manualRefresh').addEventListener('click', function() {
                console.log('Manual refresh clicked');
                fetchData();
            });
        }

        function startAutoRefresh() {
            const rate = parseInt(document.getElementById('refreshRate').value);
            
            // Clear existing interval
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
            
            // Start new interval only if rate > 0 (not manual mode)
            if (rate > 0) {
                refreshInterval = setInterval(fetchData, rate);
                console.log(`Auto-refresh started with ${rate}ms interval`);
            } else {
                console.log('Manual refresh mode enabled');
            }
        }

        function updatePlotVisibility() {
            const plotType = document.getElementById('plotType').value;
            const chartsSection = document.querySelector('.charts-section');
            const mapSection = document.querySelector('.map-section');
            
            if (plotType === 'all') {
                chartsSection.style.display = 'grid';
                mapSection.style.display = 'flex';
            } else if (plotType === 'timeseries') {
                chartsSection.style.display = 'grid';
                mapSection.style.display = 'none';
            } else if (plotType === 'profile') {
                chartsSection.style.display = 'grid';
                mapSection.style.display = 'none';
            } else if (plotType === 'map') {
                chartsSection.style.display = 'none';
                mapSection.style.display = 'flex';
            }
        }

        async function fetchData() {
            try {
                const response = await fetch('/api/latest_data?limit=1000');
                const result = await response.json();
                
                console.log('API Response:', {success: result.success, count: result.count, dataLength: result.data?.length});
                
                if (result.success && result.data) {
                    currentData = result.data;
                    
                    // Debug: Show sample data times
                    if (currentData.length > 0) {
                        console.log('Sample data times:');
                        for (let i = 0; i < Math.min(3, currentData.length); i++) {
                            const time = new Date(currentData[i].time);
                            console.log(`  Record ${i}: ${currentData[i].time} -> ${time.toISOString()}`);
                        }
                    }
                    
                    updateStatus('Connected', result.count, new Date().toLocaleTimeString());
                    updateAllPlots();
                } else {
                    updateStatus('Error: ' + (result.error || 'Unknown error'), 0, new Date().toLocaleTimeString());
                }
            } catch (error) {
                console.error('Fetch error:', error);
                updateStatus('Connection Error: ' + error.message, 0, new Date().toLocaleTimeString());
            }
        }

        function updateStatus(status, count, time) {
            document.getElementById('statusText').textContent = status;
            document.getElementById('recordCount').textContent = count;
            document.getElementById('lastUpdate').textContent = time;
            
            // Update manual refresh button state
            const manualButton = document.getElementById('manualRefresh');
            const refreshRate = parseInt(document.getElementById('refreshRate').value);
            if (refreshRate === 0) {
                manualButton.style.background = '#e3f2fd';
                manualButton.style.borderColor = '#2196f3';
                manualButton.textContent = 'Manual Refresh (Active)';
            } else {
                manualButton.style.background = '#f8f9fa';
                manualButton.style.borderColor = '#ddd';
                manualButton.textContent = 'Manual Refresh';
            }
        }

        function updateAllPlots() {
            if (currentData.length === 0) return;

            updateTimeSeriesPlots();
            updateProfilePlot();
            updateMapPlot();
        }

        function getTimeFilteredData() {
            const timeGranularity = document.getElementById('timeGranularity').value;
            
            // For real-time testing, we need to adjust time filtering since data timestamps are in +08:00
            // but we want to show recent data regardless of timezone
            const nowUTC = new Date();
            console.log(`Current UTC time: ${nowUTC.toISOString()}`);
            
            if (currentData.length > 0) {
                const firstTime = new Date(currentData[0].time);
                const lastTime = new Date(currentData[currentData.length - 1].time);
                console.log(`Data time range: ${firstTime.toISOString()} to ${lastTime.toISOString()}`);
            }
            
            // For testing purposes, if data is older than 1 hour, show all data for '1h' selection
            // This allows testing with simulated data that might be hours old
            if (currentData.length > 0) {
                const latestDataTime = new Date(currentData[currentData.length - 1].time);
                const dataAgeHours = (nowUTC.getTime() - latestDataTime.getTime()) / (1000 * 60 * 60);
                
                if (dataAgeHours > 1 && (timeGranularity === '1h' || timeGranularity === '6h')) {
                    console.log(`Data is ${dataAgeHours.toFixed(1)} hours old, showing all data for testing`);
                    return currentData;
                }
            }
            
            let cutoffTimeUTC;
            
            switch (timeGranularity) {
                case '1h':
                    cutoffTimeUTC = new Date(nowUTC.getTime() - 1 * 60 * 60 * 1000);
                    break;
                case '6h':
                    cutoffTimeUTC = new Date(nowUTC.getTime() - 6 * 60 * 60 * 1000);
                    break;
                case '12h':
                    cutoffTimeUTC = new Date(nowUTC.getTime() - 12 * 60 * 60 * 1000);
                    break;
                case '24h':
                    cutoffTimeUTC = new Date(nowUTC.getTime() - 24 * 60 * 60 * 1000);
                    break;
                case '3d':
                    cutoffTimeUTC = new Date(nowUTC.getTime() - 3 * 24 * 60 * 60 * 1000);
                    break;
                case '7d':
                    cutoffTimeUTC = new Date(nowUTC.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case '30d':
                    cutoffTimeUTC = new Date(nowUTC.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                case 'all':
                default:
                    return currentData;
            }
            
            console.log(`Cutoff time for ${timeGranularity}: ${cutoffTimeUTC.toISOString()}`);
            
            const filtered = currentData.filter(d => {
                const dataTime = new Date(d.time);
                const isInRange = dataTime >= cutoffTimeUTC;
                if (!isInRange && currentData.indexOf(d) < 5) { // Debug first few records
                    console.log(`Record ${currentData.indexOf(d)}: ${dataTime.toISOString()} < ${cutoffTimeUTC.toISOString()}`);
                }
                return isInRange;
            });
            
            console.log(`Filtered ${filtered.length} records from ${currentData.length} total`);
            return filtered;
        }

        function updateTimeSeriesPlots() {
            const filteredData = getTimeFilteredData();
            const times = filteredData.map(d => new Date(d.time)).filter(t => !isNaN(t));
            const temps = filteredData.map(d => d.tv290c).filter(v => v !== null);
            const salinities = filteredData.map(d => d.sal00).filter(v => v !== null);
            const oxygens = filteredData.map(d => d.sbeox0mm_l).filter(v => v !== null);
            
            console.log(`Time filtering: ${filteredData.length} records from ${currentData.length} total`);
            if (times.length > 0) {
                console.log(`Time range: ${times[0].toISOString()} to ${times[times.length-1].toISOString()}`);
            }
            
            // For better visualization, limit to reasonable number of points
            const maxPoints = 500;
            if (times.length > maxPoints) {
                const step = Math.ceil(times.length / maxPoints);
                const sampledTimes = [];
                const sampledTemps = [];
                const sampledSalinities = [];
                const sampledOxygens = [];
                
                for (let i = 0; i < times.length; i += step) {
                    sampledTimes.push(times[i]);
                    sampledTemps.push(temps[i]);
                    sampledSalinities.push(salinities[i]);
                    sampledOxygens.push(oxygens[i]);
                }
                
                times.splice(0, times.length, ...sampledTimes);
                temps.splice(0, temps.length, ...sampledTemps);
                salinities.splice(0, salinities.length, ...sampledSalinities);
                oxygens.splice(0, oxygens.length, ...sampledOxygens);
            }

            // Determine data timezone from first record
            let dataTimezone = 'UTC';
            if (filteredData.length > 0 && filteredData[0].time) {
                const timeStr = filteredData[0].time;
                if (timeStr.includes('+08:00')) {
                    dataTimezone = 'CST (UTC+8)';
                } else if (timeStr.includes('+00:00') || timeStr.includes('Z')) {
                    dataTimezone = 'UTC';
                } else if (timeStr.includes('-')) {
                    dataTimezone = 'Local';
                }
            }
            
            // Get time range for title
            const timeGranularity = document.getElementById('timeGranularity').value;
            const timeRangeTitle = timeGranularity === 'all' ? `All Data (${dataTimezone})` : `Last ${timeGranularity.toUpperCase()} (${dataTimezone})`;
            
            // Temperature plot
            Plotly.react('temp-plot', [{
                x: times,
                y: temps,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Temperature',
                line: {color: '#e74c3c', width: 2},
                marker: {size: 4}
            }], {
                title: `Temperature vs Time (${timeRangeTitle})`,
                xaxis: {
                    title: `Time (${dataTimezone})`,
                    type: 'date',
                    tickformat: timeGranularity === '1h' || timeGranularity === '6h' ? '%H:%M:%S' : 
                               timeGranularity === '12h' || timeGranularity === '24h' ? '%m/%d %H:%M' : 
                               '%m/%d'
                },
                yaxis: {title: 'Temperature (°C)'},
                margin: {t: 40, r: 20, b: 40, l: 50}
            });

            // Salinity plot
            Plotly.react('salinity-plot', [{
                x: times,
                y: salinities,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Salinity',
                line: {color: '#3498db', width: 2},
                marker: {size: 4}
            }], {
                title: `Salinity vs Time (${timeRangeTitle})`,
                xaxis: {
                    title: `Time (${dataTimezone})`,
                    type: 'date',
                    tickformat: timeGranularity === '1h' || timeGranularity === '6h' ? '%H:%M:%S' : 
                               timeGranularity === '12h' || timeGranularity === '24h' ? '%m/%d %H:%M' : 
                               '%m/%d'
                },
                yaxis: {title: 'Salinity (PSU)'},
                margin: {t: 40, r: 20, b: 40, l: 50}
            });

            // Oxygen plot
            Plotly.react('oxygen-plot', [{
                x: times,
                y: oxygens,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Oxygen',
                line: {color: '#2ecc71', width: 2},
                marker: {size: 4}
            }], {
                title: `Oxygen vs Time (${timeRangeTitle})`,
                xaxis: {
                    title: `Time (${dataTimezone})`,
                    type: 'date',
                    tickformat: timeGranularity === '1h' || timeGranularity === '6h' ? '%H:%M:%S' : 
                               timeGranularity === '12h' || timeGranularity === '24h' ? '%m/%d %H:%M' : 
                               '%m/%d'
                },
                yaxis: {title: 'Oxygen (mg/L)'},
                margin: {t: 40, r: 20, b: 40, l: 50}
            });
        }

        function updateProfilePlot() {
            const filteredData = getTimeFilteredData();
            const depths = filteredData.map(d => d.depth).filter(v => v !== null);
            const temps = filteredData.map(d => d.tv290c).filter(v => v !== null);
            
            // Determine data timezone from first record
            let dataTimezone = 'UTC';
            if (filteredData.length > 0 && filteredData[0].time) {
                const timeStr = filteredData[0].time;
                if (timeStr.includes('+08:00')) {
                    dataTimezone = 'CST (UTC+8)';
                } else if (timeStr.includes('+00:00') || timeStr.includes('Z')) {
                    dataTimezone = 'UTC';
                } else if (timeStr.includes('-')) {
                    dataTimezone = 'Local';
                }
            }
            
            // Get time range for title
            const timeGranularity = document.getElementById('timeGranularity').value;
            const timeRangeTitle = timeGranularity === 'all' ? `All Data (${dataTimezone})` : `Last ${timeGranularity.toUpperCase()} (${dataTimezone})`;

            Plotly.react('profile-plot', [{
                x: temps,
                y: depths,
                type: 'scatter',
                mode: 'markers',
                name: 'Temperature Profile',
                marker: {
                    color: temps,
                    colorscale: 'Viridis',
                    size: 6,
                    colorbar: {title: 'Temperature (°C)'}
                }
            }], {
                title: `Temperature vs Depth (${timeRangeTitle})`,
                xaxis: {title: 'Temperature (°C)'},
                yaxis: {title: 'Depth (m)', autorange: 'reversed'},
                margin: {t: 40, r: 20, b: 40, l: 50}
            });
        }

        function updateMapPlot() {
            const filteredData = getTimeFilteredData();
            const lats = filteredData.map(d => d.latitude).filter(v => v !== null && v !== undefined);
            const lons = filteredData.map(d => d.longitude).filter(v => v !== null && v !== undefined);
            const temperatures = filteredData.map(d => d.tv290c).filter(v => v !== null && v !== undefined);

            console.log('Map data:', {lats: lats.length, lons: lons.length, temps: temperatures.length});
            console.log('Sample coords:', {lat: lats[0], lon: lons[0]});
            console.log('All lats:', lats.slice(0, 5));
            console.log('All lons:', lons.slice(0, 5));

            if (lats.length === 0 || lons.length === 0) {
                console.log('No valid coordinates for map');
                return;
            }

            // Use the most recent position as center (current position)
            const centerLat = lats[lats.length - 1];
            const centerLon = lons[lons.length - 1];

            console.log('Map center (current position):', {centerLat, centerLon, zoom: mapZoomLevel});

            try {
                // Trajectory line
                const trajectoryTrace = {
                    type: 'scattermapbox',
                    lat: lats,
                    lon: lons,
                    mode: 'lines',
                    line: {color: '#3498db', width: 3},
                    name: 'Trajectory',
                    showlegend: false
                };

                // History position points
                const historyTrace = {
                    type: 'scattermapbox',
                    lat: lats.slice(0, -1), // All points except the last one
                    lon: lons.slice(0, -1),
                    mode: 'markers',
                    marker: {
                        size: 6,
                        color: temperatures.slice(0, -1),
                        colorscale: 'Viridis',
                        colorbar: {title: 'Temperature (°C)'},
                        opacity: 0.6
                    },
                    name: 'History',
                    showlegend: false
                };

                // Current position point (red dot)
                const currentTrace = {
                    type: 'scattermapbox',
                    lat: [lats[lats.length - 1]], // Last point
                    lon: [lons[lons.length - 1]],
                    mode: 'markers',
                    marker: {
                        size: 15,
                        color: '#e74c3c',
                        symbol: 'circle',
                        opacity: 1.0,
                        line: {
                            color: '#ffffff',
                            width: 2
                        }
                    },
                    name: 'Current Position',
                    showlegend: false,
                    hovertemplate: '<b>Current Position</b><br>' +
                                  'Lat: %{lat:.5f}<br>' +
                                  'Lon: %{lon:.5f}<br>' +
                                  'Temp: ' + (temperatures[temperatures.length - 1] || 'N/A') + '°C<br>' +
                                  '<extra></extra>'
                };

                // Determine data timezone from first record
                let dataTimezone = 'UTC';
                if (filteredData.length > 0 && filteredData[0].time) {
                    const timeStr = filteredData[0].time;
                    if (timeStr.includes('+08:00')) {
                        dataTimezone = 'CST (UTC+8)';
                    } else if (timeStr.includes('+00:00') || timeStr.includes('Z')) {
                        dataTimezone = 'UTC';
                    } else if (timeStr.includes('-')) {
                        dataTimezone = 'Local';
                    }
                }
                
                // Get time range for title
                const timeGranularity = document.getElementById('timeGranularity').value;
                const timeRangeTitle = timeGranularity === 'all' ? `All Data (${dataTimezone})` : `Last ${timeGranularity.toUpperCase()} (${dataTimezone})`;
                
                const layout = {
                    mapbox: {
                        style: 'open-street-map',
                        center: {lat: centerLat, lon: centerLon},
                        zoom: mapZoomLevel
                    },
                    title: `Oceanographic Track - Real-time Position (${timeRangeTitle})`,
                    margin: {t: 40, r: 20, b: 20, l: 20}
                };

                const config = {
                    mapboxAccessToken: 'pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw'
                };

                console.log('Plotting map with traces:', [trajectoryTrace, historyTrace, currentTrace]);
                console.log('Layout:', layout);
                console.log('Config:', config);

                Plotly.react('map-plot', [trajectoryTrace, historyTrace, currentTrace], layout, config);
                console.log('Map plot updated successfully with current position marker');
            } catch (error) {
                console.error('Map plot error:', error);
            }
        }
    </script>
</body>
</html>
